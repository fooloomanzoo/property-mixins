<link rel="import" href="../polymer/lib/utils/mixin.html">
<link rel="import" href="number-utilities.html">

<script>
  /**
   * Mixin that provides web-color-properties. Its `color-string` converts automatically beetween different formats (hex, rgb and hsl) and provides an alpha-colorString.
   *
   * @mixinFunction
   * @polymer
   *
   * @demo demo/color-demo.html
   */
  const ColorMixin = function(superClass) { // eslint-disable-line no-unused-vars no-undef

    return class extends superClass {

      constructor() {
        super();
        this._validFormats = ['rgb', 'hex', 'hsl', 'auto'];
        this._validateRgb = /rgb(a)?\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)/;
        this._validateHex = /(?:(#[A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?|(#[A-Fa-f0-9]{3})([A-Fa-f0-9])?)/;
        this._validateHsl = /hsl(a)?\(\s*(-?\d+(?:\.\d*)?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)/;
        this._defaultValidateColorString = /[\w().,#\s]*/;
        this._validatePercent = /(-?\d*(?:\.(?:\d*)?)?)%/;
        this.randomColor = this.randomColor.bind(this);
        this.resetColor = this.resetColor.bind(this);
      }

      static get properties() {
        return {
          /**
           * Hex-color
           */
          hex: {
            type: String,
            notify: true,
            observer: '_hexChanged'
          },
          /**
           * Red
           */
          r: {
            type: Number,
            notify: true
          },
          /**
           * Green
           */
          g: {
            type: Number,
            notify: true
          },
          /**
           * Blue
           */
          b: {
            type: Number,
            notify: true
          },
          /**
           * Hue
           */
          h: {
            type: Number,
            notify: true
          },
          /**
           * Saturation (hsl)
           */
          s: {
            type: Number,
            notify: true
          },
          /**
           * Lightness
           */
          l: {
            type: Number,
            notify: true
          },
          /**
           * Alpha
           */
          alpha: {
            type: Number,
            notify: true,
            value: 1,
            observer: '_alphaChanged'
          },
          /**
           * if true, colorString has alpha
           */
          alphaMode: {
            type: Boolean,
            notify: true,
            observer: '_alphaModeChanged'
          },
          /**
           * Precision of hsl-colorStrings, if the format is 'hsl' (for saturation and lightness it is applied according to their percentage colorString)
           */
          hslPrecision: {
            type: Number,
            value: 0
          },
          /**
           * format of the colorString (possible colorStrings: 'rgb', 'hex', 'hsl', 'auto')
           */
          format: {
            type: String,
            notify: true,
            value: 'auto',
            observer: '_formatChanged'
          },
          /**
           * format is locked and does not switch according to the colorString
           */
          fixedFormat: {
            type: Boolean
          },
          /**
           * if true, hex alpha is supported by the browser
           */
          _hexAlphaSupported: {
            type: Boolean,
            readOnly: true
          },
          /**
           * value as color-string
           */
          colorString: {
            type: String,
            notify: true,
            observer: '_colorStringChanged'
          }
        }
      }

      static get observers() {
        return [
          '_rgbChanged(r, g, b)',
          '_hslChanged(h, s, l)'
        ];
      }

      connectedCallback() {
        super.connectedCallback();
        this._createTestCanvas();
        if (!(isNaN(this.r) && isNaN(this.g) && isNaN(this.b))) {
          const rgb = this.randomRgb();
          this.setProperties({
            r: isNaN(this.r) ? rgb.r : this.r,
            g: isNaN(this.g) ? rgb.g : this.g,
            b: isNaN(this.b) ? rgb.b : this.b
          });
        } else if (!(isNaN(this.h) && isNaN(this.s) && isNaN(this.l))) {
          const hsl = this.randomHsl();
          this.setProperties({
            h: isNaN(this.h) ? hsl.h : this.h,
            s: isNaN(this.s) ? hsl.s : this.s,
            l: isNaN(this.l) ? hsl.l : this.l
          });
        }
      }

      /**
       * generate random color
       */
      randomColor() {
        this.__internalForcedUpdate = true;
        this.setProperties(this.randomRgb());
      }

      /**
       * generate random rgb-color
       * @return {object} rgb-color object
       */
      randomRgb() {
        return {
          r: Math.round(255 * Math.random()),
          g: Math.round(255 * Math.random()),
          b: Math.round(255 * Math.random())
        };
      }

      /**
       * generate random hsl-color
       * @return {object} rgb-color object
       */
      randomHsl() {
        return {
          h: Math.round(359 * Math.random()),
          s: Math.random(),
          l: Math.random()
        };
      }

      /**
       * reset all color properties
       */
      resetColor() {
        this.setProperties({
          colorString: undefined,
          r: undefined,
          g: undefined,
          b: undefined,
          h: undefined,
          s: undefined,
          l: undefined,
          hex: undefined,
          alpha: 1
        })
      }

      _createTestCanvas() {
        const testcanvas = document.createElement('canvas');
        testcanvas.width = 1;
        testcanvas.height = 1;
        testcanvas.style.visibility = 'hidden';
        testcanvas.style.pointerEvents = 'none';
        testcanvas.style.position = 'fixed';
        this.appendChild(testcanvas);
        this._testCanvasContext = testcanvas.getContext("2d");
        // test if `#rrggbbaa` is supported
        const rgba = this._testColor('#ff000080');
        this._set_hexAlphaSupported(rgba.r === 255 && rgba.g === 0 && rgba.b === 0 && rgba.alpha === 0.5);
      }

      _testColor(value) {
        if (!this._testCanvasContext) {
          this._createTestCanvas();
        }
        this._testCanvasContext.clearRect(0, 0, 1, 1);
        this._testCanvasContext.fillStyle = value || 'rgba(0,0,0,1)';
        this._testCanvasContext.fillRect(0, 0, 1, 1);
        const imgData = this._testCanvasContext.getImageData(0, 0, 1, 1);
        return {
          r: imgData.data[0],
          g: imgData.data[1],
          b: imgData.data[2],
          alpha: this._hexToAlpha(imgData.data[3].toString(16), 2),
          alphaMode: imgData.data[3] !== 255
        }
      }

      _alphaModeChanged(alphaMode) {
        if (alphaMode !== true) {
          this.alpha = 1;
        }
      }

      _formatChanged(format, oldFormat) {
        if (format === undefined || this.___internalForcedUpdate) {
          return;
        }
        if (this._validFormats.indexOf(format) === -1) {
          if (oldFormat && this._validFormats.indexOf(oldFormat) !== -1) {
            this.format = oldFormat;
            return;
          }
          this.format = 'auto';
          return;
        }

        const colorString = this._computeColorString(this.hex, this.r, this.g, this.b, this.h, this.s, this.l);
        if (colorString !== this.colorString) {
          this.colorString = colorString;
        }
      }

      _colorStringChanged(colorString) {
        if (!colorString) {
          this.resetColor();
          return;
        }
        let toSet = {},
          match,
          format;
        // input-format detection

        // hsl-format
        if (match = colorString.match(this._validateHsl)) {
          format = 'hsl';
          if (match[1] === undefined) { // no alpha
            toSet.alpha = 1;
            toSet.alphaMode = false;
          } else { // with alpha
            toSet.alpha = this._normalizedClamp(+match[5]);
            toSet.alphaMode = true;
          }
          toSet.h = +match[2];
          let matchPercent;
          if (matchPercent = match[3].match(this._validatePercent)) { // s in percentage colorString
            toSet.s = +matchPercent[1] * 0.01;
          } else {
            toSet.s = +match[3];
          }
          if (matchPercent = match[4].match(this._validatePercent)) { // l in percentage colorString
            toSet.l = +matchPercent[1] * 0.01;
          } else {
            toSet.l = +match[4];
          }
          toSet = this._normalizeHsl(toSet);
          // rgb-format
        } else if (match = colorString.match(this._validateRgb)) {
          format = 'rgb';
          if (match[1] === undefined) { // no alpha
            toSet.alpha = 1;
            toSet.alphaMode = false;
          } else { // with alpha
            toSet.alpha = this._normalizedClamp(+match[5]);
            toSet.alphaMode = true;
          }
          Object.assign(toSet, this._normalizeRgb({r: +match[2], g: +match[3], b: +match[4]}));
          // hex-format
        } else if (match = colorString.match(this._validateHex)) {
          format = 'hex';
          if (match[1] !== undefined) { // six hex numbers
            toSet.hex = match[1];
            if (match[2] !== undefined) { // alpha channel has two hex numbers
              toSet.alpha = this._hexToAlpha(match[2], 2);
              toSet.alphaMode = true;
            } else { // no alpha channel
              toSet.alpha = 1;
              toSet.alphaMode = false;
            }
          } else if (match[3] !== undefined) { // three hex numbers
            toSet.hex = match[3];
            if (match[4] !== undefined) { // alpha channel has one hex number
              toSet.alpha = this._hexToAlpha(match[4], 1);
              toSet.alphaMode = true;
            } else { // no alpha channel
              toSet.alpha = 1;
              toSet.alphaMode = false;
            }
          }
        } else {
          // last try
          format = 'auto';
          toSet = this._testColor(colorString);
        }
        if (this.format !== format && !this.fixedFormat) {
          toSet.format = format;
        }
        this.__internalForcedUpdate = true;
        this.setProperties(toSet);
      }

      _computeColorString(hex, r, g, b, h, s, l) {
        switch (this.format) {
          case 'hsl':
            if (!isNaN(h) && !isNaN(s) && !isNaN(l)) {
              if (this.alphaMode === true || this.alpha !== 1) {
                return `hsla(${h.toFixed(this.hslPrecision || 0)}, ${(s*100).toFixed(this.hslPrecision || 0)}%, ${(l*100).toFixed(this.hslPrecision || 0)}%, ${this.alpha === undefined ? 1 : this.alpha})`;
              } else {
                return `hsl(${h.toFixed(this.hslPrecision || 0)}, ${(s*100).toFixed(this.hslPrecision || 0)}%, ${(l*100).toFixed(this.hslPrecision || 0)}%)`;
              }
            }
            break;
          case 'auto':
            if (!this.alphaMode) {
              // keeping color string if possible
              const rgba = this._testColor(this.colorString);
              if (rgba.r === r && rgba.b === this.b && rgba.g === this.g) {
                return this.colorString;
              }
            } // falls through
          case 'hex':
            if (hex !== undefined) {
              if (this.alphaMode === true) {
                if (this._hexAlphaSupported) {
                  return `${hex}${this._alphaToHex(this.alpha, hex.length <= 4 ? 1 : 2)}`;
                }
              } else {
                return hex;
              }
            } // falls through
          case 'rgb':
          default:
            if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
              if (this.alphaMode === true || this.alpha !== 1) {
                return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${this.alpha === undefined ? 1 : this.alpha})`;
              } else {
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
              }
            }
        }
      }

      _alphaChanged(alpha, oldAlpha) {
        if (this.___internalForcedUpdate) {
          return;
        }
        if (isNaN(alpha)) {
          this.alpha = 1;
          return;
        }
        if (alpha > 1) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 1;
          return;
        }
        if (alpha < 0) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 0;
          return;
        }
        if (alpha !== 1) {
          this.alphaMode = true;
        }
        const colorString = this._computeColorString(this.hex, this.r, this.g, this.b, this.h, this.s, this.l);
        if (colorString !== this.colorString) {
          this.colorString = colorString;
        }
      }

      _hexChanged(hex) {
        if (!hex) {
          this.resetColor();
          return;
        }
        if (this.format !== 'hex' && !this.__internalForcedUpdate) {
          this._rgbChanged(this.r, this.g, this.b);
          return;
        }
        let toSet = {};

        let rgb = this.hexToRgb(hex);
        if (!(this.r === rgb.r && this.g === rgb.g && this.b === rgb.b)) {
          this.setProperties(rgb);
        }
      }

      _rgbChanged(r, g, b) {
        if (this.format === 'hsl' && !this.__internalForcedUpdate) {
          // hsl and rgb are not inversable
          this._hslChanged(this.h, this.s, this.l);
          return;
        }
        if (isNaN(r) || isNaN(g) || isNaN(b)) {
          // single property can be set without triggering property changes
          return;
        }

        let rgb = this._normalizeRgb({r: r, g: g, b: b});
        if (!(rgb.r === this.r && rgb.g === this.g && rgb.b === this.b)) {
          // transformed rgb is different than the current rgb, so set the rgb
          this.setProperties(rgb);
          return;
        }
        this.__internalForcedUpdate = false;

        let toSet = {};
        let hsl = this._normalizeHsl(this.rgbToHsl(rgb, this.h));
        if (!(this.h === hsl.h && this.s === hsl.s && this.l === hsl.l)) {
          toSet = hsl;
        }

        const hex = this.rgbToHex(rgb);
        if (hex !== this.hex) {
          toSet.hex = hex;
        }
        const colorString = this._computeColorString(hex, rgb.r, rgb.g, rgb.b, hsl.h, hsl.s, hsl.l);
        if (colorString !== this.colorString) {
          toSet.colorString = colorString;
        }
        this.setProperties(toSet);
      }

      _hslChanged(h, s, l) {
        if (this.format !== 'hsl' && !this.__internalForcedUpdate) {
          // hsl and rgb are not inversable
          this._rgbChanged(this.r, this.g, this.b);
          return;
        }
        if (isNaN(h) || isNaN(s) || isNaN(l)) {
          // single property can be set without triggering property changes
          return;
        }

        let hsl = this._normalizeHsl({h: h, s: s, l: l});
        if (!(this.h === hsl.h && this.s === hsl.s && this.l === hsl.l)) {
          // transformed hsl is different than the current hsl, so set the hsl
          this.setProperties(hsl);
          return;
        }
        this.__internalForcedUpdate = false;

        let toSet = {};
        const rgb = this._normalizeRgb(this.hslToRgb(hsl));
        if (!(rgb.r === this.r && rgb.g === this.g && rgb.b === this.b)) {
          toSet = rgb;
        }

        const hex = this.rgbToHex(rgb);
        if (hex !== this.hex) {
          toSet.hex = hex;
        }
        const colorString = this._computeColorString(hex, rgb.r, rgb.g, rgb.b, hsl.h, hsl.s, hsl.l);
        if (colorString !== this.colorString) {
          toSet.colorString = colorString;
        }
        this.setProperties(toSet);
      }

      _normalizeRgb(rgb) {
        rgb.r = this._mathMod(Math.round(rgb.r), 256);
        rgb.g = this._mathMod(Math.round(rgb.g), 256);
        rgb.b = this._mathMod(Math.round(rgb.b), 256);
        return rgb;
      }

      _normalizeHsl(hsl) {
        hsl.h = this._mathMod(+hsl.h.toFixed(this.hslPrecision || 0), 360);
        hsl.s = this._normalizedClamp(+hsl.s.toFixed((this.hslPrecision || 0) + 2));
        hsl.l = this._normalizedClamp(+hsl.l.toFixed((this.hslPrecision || 0) + 2));
        return hsl;
      }

      hexToRgb(hex) {
        if (hex === undefined) {
          return;
        }
        hex = hex.slice(1);
        if (hex.length === 3) {
          hex = hex.replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
        }
        return {
          r: parseInt(hex.substr(0, 2), 16),
          g: parseInt(hex.substr(2, 2), 16),
          b: parseInt(hex.substr(4, 2), 16)
        };
      }

      rgbToHex(rgb) {
        if (isNaN(rgb.r) || isNaN(rgb.g) || isNaN(rgb.b)) {
          return;
        }
        return '#' + this._componentToHex(Math.round(rgb.r)) + this._componentToHex(Math.round(rgb.g)) + this._componentToHex(Math.round(rgb.b));
      }

      _componentToHex(component) {
        const _hex = component.toString(16);
        if (_hex.length === 1) {
          return `0${_hex}`;
        } else {
          return _hex.slice(0, 2);
        }
      }

      _alphaToHex(alpha, length) {
        const base = Math.pow(16, length) - 1;
        let hex = (Math.round(alpha * base)).toString(16);
        while (length > hex.length)
          hex = '0' + hex;
        return hex;
      }

      _hexToAlpha(hex, length) {
        const base = Math.pow(16, length) - 1;
        // rounding, because browser do use for
        return Math.round(100 * (parseInt(hex, 16) / base)) / 100;
      }

      /**
       * convert hsl to rgb (the values are not rounded)
       * @param  {Object} hsl  hsl object
       * @return {Object}      rgb object
       */
      hslToRgb(hsl) { // not rounded yet
        if (isNaN(hsl.h) || isNaN(hsl.s) || isNaN(hsl.l)) {
          return;
        }
        const t2 = ((hsl.l <= 0.5) ? hsl.l * (hsl.s + 1) : hsl.l + hsl.s - (hsl.l * hsl.s)) * 255,
          t1 = hsl.l * 2 * 255 - t2;
        return {
          r: this._mathMod(this.hueToComponent(t1, t2, hsl.h + 120), 256),
          g: this._mathMod(this.hueToComponent(t1, t2, hsl.h), 256),
          b: this._mathMod(this.hueToComponent(t1, t2, hsl.h - 120), 256)
        };
      }

      hueToComponent(t1, t2, h) {
        if (h < 0) h += 360;
        if (h >= 360) h -= 360;
        if (h < 60) return (((t2 - t1) * h) / 60 + t1);
        else if (h < 180) return t2;
        else if (h < 240) return (((t2 - t1) * (240 - h)) / 60 + t1);
        else return t1;
      }

      /**
       * convert rgb to hsl (the values are not rounded)
       * @param  {Object} rgb  rgb object
       * @param  {Number} defaultH hue to set if saturation is 0
       * @return {Object}      hsl object
       */
      rgbToHsl(rgb, defaultH) {
        if (isNaN(rgb.r) || isNaN(rgb.g) || isNaN(rgb.b)) {
          return;
        }
        const max = Math.max(rgb.r, rgb.g, rgb.b),
          min = Math.min(rgb.r, rgb.g, rgb.b);

        const l = (max + min) / (2 * 255);
        const _c = max - min; // not-normalized chroma (for precision)

        if (_c === 0) {
          return {
            h: defaultH || 0,
            s: 0,
            l: this._normalizedClamp(l)
          };
        }

        const s = _c / (255 - Math.abs(max + min - 255));
        let h;
        switch (max) {
          case rgb.r:
            h = ((rgb.g - rgb.b) * 60) / _c;
            break;
          case rgb.g:
            h = (((rgb.b - rgb.r) * 60) / _c) + 120;
            break;
          case rgb.b:
            h = (((rgb.r - rgb.g) * 60) / _c) + 240;
            break;
        }
        return {
          h: this._mathMod(h, 360),
          s: this._normalizedClamp(s),
          l: this._normalizedClamp(l)
        };
      }

      _mathMod(dividend, divisor) {
        return numberUtilities.mathMod(dividend, divisor);
      }

      _normalizedClamp(n) {
        return numberUtilities.normalizedClamp(n);
      }
    }
  }
  window.ColorMixin = Polymer.dedupingMixin(ColorMixin);
</script>
