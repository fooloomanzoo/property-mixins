<link rel="import" href="../polymer/lib/utils/mixin.html">
<link rel="import" href="number-utilities.html">

<script>
  /**
   * Mixin that provides web-color-properties. Its `color-string` converts automatically beetween different formats (hex, rgb and hsl) and provides an alpha-colorString.
   *
   * @mixinFunction
   * @polymer
   *
   * @demo demo/color-demo.html
   */
  const ColorMixin = function(superClass) { // eslint-disable-line no-unused-vars no-undef

    return class extends superClass {

      constructor() {
        super();
        this._validFormats = ['rgb', 'hex', 'hsl', 'auto'];
        this._validateRgb = /^\s*rgb(a)?\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)\s*$/;
        this._validateHex = /^\s*(?:(#[A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?|(#[A-Fa-f0-9]{3})([A-Fa-f0-9])?)\s*$/;
        this._validateHsl = /^\s*hsl(a)?\(\s*(-?\d+(?:\.\d*)?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)\s*$/;
        this._defaultValidateColorString = /[\w().,#\s]*/;
        this._validatePercent = /(-?\d*(?:\.(?:\d*)?)?)%/;
        this.randomColor = this.randomColor.bind(this);
        this.resetColor = this.resetColor.bind(this);
      }

      static get properties() {
        return {
          /**
           * Hex-color
           */
          hex: {
            type: String,
            notify: true,
            observer: '_hexChanged'
          },
          /**
           * Red
           */
          r: {
            type: Number,
            notify: true
          },
          /**
           * Green
           */
          g: {
            type: Number,
            notify: true
          },
          /**
           * Blue
           */
          b: {
            type: Number,
            notify: true
          },
          /**
           * Hue
           */
          h: {
            type: Number,
            notify: true
          },
          /**
           * Saturation (hsl)
           */
          s: {
            type: Number,
            notify: true
          },
          /**
           * Lightness
           */
          l: {
            type: Number,
            notify: true
          },
          /**
           * Alpha
           */
          alpha: {
            type: Number,
            notify: true,
            value: 1,
            observer: '_alphaChanged'
          },
          /**
           * if true, colorString has alpha
           */
          alphaMode: {
            type: Boolean,
            notify: true,
            observer: '_alphaModeChanged'
          },
          /**
           * Precision of hsl-colorStrings, if the format is 'hsl' (for saturation and lightness it is applied according to their percentage colorString)
           */
          hslPrecision: {
            type: Number,
            value: 0
          },
          /**
           * format of the colorString (possible colorStrings: 'rgb', 'hex', 'hsl', 'auto')
           */
          format: {
            type: String,
            notify: true,
            value: 'auto',
            observer: '_formatChanged'
          },
          /**
           * format is locked and does not switch according to the colorString
           */
          fixedFormat: {
            type: Boolean
          },
          /**
           * if true, hex alpha is supported by the browser
           */
          _hexAlphaSupported: {
            type: Boolean,
            readOnly: true
          },
          /**
           * value as color-string
           */
          colorString: {
            type: String,
            notify: true,
            observer: '_colorStringChanged'
          }
        }
      }

      static get observers() {
        return [
          '_rgbChanged(r, g, b)',
          '_hslChanged(h, s, l)'
        ];
      }

      connectedCallback() {
        super.connectedCallback();
        this._createTestCanvas();
        if (!(isNaN(this.r) && isNaN(this.g) && isNaN(this.b))) {
          const rgb = this.randomRgb();
          this.setProperties({
            r: isNaN(this.r) ? rgb.r : this.r,
            g: isNaN(this.g) ? rgb.g : this.g,
            b: isNaN(this.b) ? rgb.b : this.b
          });
        } else if (!(isNaN(this.h) && isNaN(this.s) && isNaN(this.l))) {
          const hsl = this.randomHsl();
          this.setProperties({
            h: isNaN(this.h) ? hsl.h : this.h,
            s: isNaN(this.s) ? hsl.s : this.s,
            l: isNaN(this.l) ? hsl.l : this.l
          });
        }
      }

      _createTestCanvas() {
        const testcanvas = document.createElement('canvas');
        testcanvas.width = 1;
        testcanvas.height = 1;
        testcanvas.style.visibility = 'hidden';
        testcanvas.style.pointerEvents = 'none';
        testcanvas.style.position = 'fixed';
        this.appendChild(testcanvas);
        this._testCanvasContext = testcanvas.getContext("2d");
        // test if `#rrggbbaa` is supported
        const rgba = this._testColor('#ff000080');
        this._set_hexAlphaSupported(rgba.r === 255 && rgba.g === 0 && rgba.b === 0 && rgba.alpha === 0.5);
      }

      _testColor(value) {
        if (!this._testCanvasContext) {
          this._createTestCanvas();
        }
        this._testCanvasContext.clearRect(0, 0, 1, 1);
        this._testCanvasContext.fillStyle = value || 'rgba(0,0,0,1)';
        this._testCanvasContext.fillRect(0, 0, 1, 1);
        const imgData = this._testCanvasContext.getImageData(0, 0, 1, 1);
        return {
          r: imgData.data[0],
          g: imgData.data[1],
          b: imgData.data[2],
          alpha: this._hexToAlpha(imgData.data[3].toString(16), 2),
          alphaMode: imgData.data[3] !== 255
        }
      }

      _alphaModeChanged(alphaMode) {
        if (alphaMode !== true) {
          this.alpha = 1;
        }
      }

      _formatChanged(format, oldFormat) {
        if (format === undefined) {
          return;
        }
        if (this._validFormats.indexOf(format) === -1) {
          if (oldFormat && this._validFormats.indexOf(oldFormat) !== -1) {
            this.format = oldFormat;
            return;
          }
          this.format = 'auto';
          return;
        }

        const colorString = this._computeColorString(this.hex, this.r, this.g, this.b, this.h, this.s, this.l, this.alpha);
        if (colorString !== this.colorString) {
          this.colorString = colorString;
        }
      }

      _colorStringChanged(colorString) {
        if (!colorString) {
          this.resetColor();
          return;
        }
        let toSet = {},
          match,
          format;
        // input-format detection
        // hsl-format
        if (match = colorString.match(this._validateHsl)) {
          if (match[1] === undefined) { // no alpha
            toSet.alpha = 1;
            toSet.alphaMode = false;
          } else { // with alpha
            toSet.alpha = this._normalizedClamp(+match[5]);
            toSet.alphaMode = true;
          }
          toSet.h = this._mathMod(+match[2], 360);
          let matchPercent;
          if (matchPercent = match[3].match(this._validatePercent)) { // s in percentage colorString
            toSet.s = this._normalizedClamp(+matchPercent[1] * 0.01);
          } else {
            toSet.s = this._normalizedClamp(+match[3]);
          }
          if (matchPercent = match[4].match(this._validatePercent)) { // l in percentage colorString
            toSet.l = this._normalizedClamp(+matchPercent[1] * 0.01);
          } else {
            toSet.l = this._normalizedClamp(+match[4]);
          }
          if (this.format !== 'hsl') {
            format = 'hsl';
            toSet.alpha = +toSet.alpha.toFixed(2);
          } else {
            toSet.h = +toSet.h.toFixed(this.hslPrecision || 0);
            toSet.s = +toSet.s.toFixed((this.hslPrecision || 0) + 2);
            toSet.l = +toSet.l.toFixed((this.hslPrecision || 0) + 2);
          }
          // rgb-format
        } else if (match = colorString.match(this._validateRgb)) {
          if (match[1] === undefined) { // no alpha
            toSet.alpha = 1;
            toSet.alphaMode = false;
          } else { // with alpha
            toSet.alpha = this._normalizedClamp(+match[5]);
            toSet.alphaMode = true;
          }
          toSet.r = this._mathMod(+match[2], 256);
          toSet.g = this._mathMod(+match[3], 256);
          toSet.b = this._mathMod(+match[4], 256);
          if (this.format !== 'rgb') {
            format = 'rgb';
            toSet.alpha = +toSet.alpha.toFixed(2);
          } else {
            toSet.r = Math.round(toSet.r);
            toSet.g = Math.round(toSet.g);
            toSet.b = Math.round(toSet.b);
          }
          // hex-format
        } else if (match = colorString.match(this._validateHex)) {
          if (match[1] !== undefined) { // six hex numbers
            toSet.hex = match[1];
            if (match[2] !== undefined) { // alpha channel has two hex numbers
              toSet.alpha = this._hexToAlpha(match[2], 2);
              toSet.alphaMode = true;
            } else { // no alpha channel
              toSet.alpha = 1;
              toSet.alphaMode = false;
            }
          } else if (match[3] !== undefined) { // three hex numbers
            toSet.hex = match[3];
            if (match[4] !== undefined) { // alpha channel has one hex number
              toSet.alpha = this._hexToAlpha(match[4], 1);
              toSet.alphaMode = true;
            } else { // no alpha channel
              toSet.alpha = 1;
              toSet.alphaMode = false;
            }
          }
          if (this.format !== 'hex') {
            format = 'hex';
          }
        } else {
          // last try
          toSet = this._testColor(colorString);
          format = 'auto';
        }
        if (!this.fixedFormat && format && this.format !== format) {
          toSet.format = format;
        }
        this.setProperties(toSet);
      }

      _computeColorString(hex, r, g, b, h, s, l, alpha) {
        switch (this.format) {
          case 'hsl':
            if (!isNaN(h) && !isNaN(s) && !isNaN(l)) {
              if (this.alphaMode === true || alpha !== 1) {
                return `hsla(${h.toFixed(this.hslPrecision || 0)}, ${(s*100).toFixed(this.hslPrecision || 0)}%, ${(l*100).toFixed(this.hslPrecision || 0)}%, ${this.alpha === undefined ? 1 : this.alpha})`;
              } else {
                return `hsl(${h.toFixed(this.hslPrecision || 0)}, ${(s*100).toFixed(this.hslPrecision || 0)}%, ${(l*100).toFixed(this.hslPrecision || 0)}%)`;
              }
            }
            break;
          case 'auto':
            if (!this.alphaMode) {
              // keeping color string if possible
              const rgba = this._testColor(this.colorString);
              if (rgba.r === r && rgba.b === this.b && rgba.g === this.g) {
                return this.colorString;
              }
            } // falls through
          case 'hex':
            if (hex !== undefined) {
              if (this.alphaMode === true) {
                if (this._hexAlphaSupported) {
                  return `${hex}${this._alphaToHex(this.alpha, hex.length <= 4 ? 1 : 2)}`;
                }
              } else {
                return hex;
              }
            } // falls through
          case 'rgb':
          default:
            if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
              if (this.alphaMode === true || this.alpha !== 1) {
                return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${this.alpha === undefined ? 1 : this.alpha})`;
              } else {
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
              }
            }
        }
      }

      _alphaChanged(alpha, oldAlpha) {
        if (isNaN(alpha)) {
          this.alpha = 1;
          return;
        }
        if (alpha > 1) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 1;
          return;
        }
        if (alpha < 0) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 0;
          return;
        }
        if (alpha !== 1) {
          this.alphaMode = true;
        }
        const colorString = this._computeColorString(this.hex, this.r, this.g, this.b, this.h, this.s, this.l, alpha);
        if (colorString !== this.colorString) {
          this.colorString = colorString;
        }
      }

      _hexChanged(hex) {
        if (!hex) {
          this.resetColor();
          return;
        }
        let toSet = {};

        let rgb = this.hexToRgb(hex);
        let transformedRgb = this._normalizeRgb({
          r: this.r,
          g: this.g,
          b: this.b
        });
        if (!(transformedRgb.r === rgb.r && transformedRgb.g === rgb.g && transformedRgb.b === rgb.b)) {
          this.setProperties(rgb);
        }

        // let hsl = this._normalizeHsl(this.rgbToHsl(rgb));
        // f (!(this.h === hsl.h || this.s === hsl.s || this.l === hsl.l)) {
        //   toSet.h = hsl.h;
        //   toSet.s = hsl.s;
        //   toSet.l = hsl.l;
        // }
        //
        // const colorString = this._computeColorString(hex, rgb.r, rgb.g, rgb.b, hsl.h, hsl.s, hsl.l);
        // if (colorString !== this.colorString) {
        //   toSet.colorString = colorString;
        // }
        // this.setProperties(toSet);
      }

      _normalizeRgb(rgb) {
        if (this.format !== 'hsl') {
          rgb.r = Math.round(rgb.r);
          rgb.g = Math.round(rgb.g);
          rgb.b = Math.round(rgb.b);
        }
        rgb.r = this._mathMod(rgb.r, 256);
        rgb.g = this._mathMod(rgb.g, 256);
        rgb.b = this._mathMod(rgb.b, 256);
        return rgb;
      }

      _normalizeHsl(hsl) {
        if (this.format === 'hsl') {
          hsl.h = +hsl.h.toFixed(this.hslPrecision || 0);
          hsl.s = +hsl.s.toFixed((this.hslPrecision || 0) + 2);
          hsl.l = +hsl.l.toFixed((this.hslPrecision || 0) + 2);
        }
        hsl.h = this._mathMod(hsl.h, 360);
        hsl.s = this._normalizedClamp(hsl.s);
        hsl.l = this._normalizedClamp(hsl.l);
        return hsl;
      }

      _rgbChanged(r, g, b) {
        if (isNaN(r) && isNaN(g) && isNaN(b)) {
          this.resetColor();
          return;
        }
        if (isNaN(r) || isNaN(g) || isNaN(b)) {
          // single property can be set without triggering property changes
          return;
        }

        let rgb = this._normalizeRgb({r: r, g: g, b: b});
        if (!(rgb.r === this.r && rgb.g === this.g && rgb.b === this.b)) {
          // transformed rgb is different than the current rgb, so set the rgb
          this.setProperties(rgb);
          return;
        }

        let toSet = {};

        let hsl = this._normalizeHsl(this.rgbToHsl(rgb));
        if (!(this.h === hsl.h && this.s === hsl.s && this.l === hsl.l)) {
          toSet = hsl;
        }

        const hex = this.rgbToHex(rgb);
        if (hex !== this.hex) {
          toSet.hex = hex;
        }
        const colorString = this._computeColorString(hex, rgb.r, rgb.g, rgb.b, hsl.h, hsl.s, hsl.l, this.alpha);
        if (colorString !== this.colorString) {
          toSet.colorString = colorString;
        }
        this.setProperties(toSet);
      }

      _hslChanged(h, s, l) {
        if (isNaN(h) && isNaN(s) && isNaN(l)) {
          this.resetColor();
          return;
        }
        if (isNaN(h) || isNaN(s) || isNaN(l)) {
          // single property can be set without triggering property changes
          return;
        }

        let hsl = this._normalizeHsl({h: h, s: s, l: l});
        if (!(this.h === hsl.h && this.s === hsl.s && this.l === hsl.l)) {
          // transformed hsl is different than the current hsl, so set the hsl
          this.setProperties(hsl);
          return;
        }

        let toSet = {};
        const rgb = this._normalizeRgb(this.hslToRgb(hsl));
        if (!(rgb.r === this.r && rgb.g === this.g && rgb.b === this.b)) {
          toSet = rgb;
        }

        const hex = this.rgbToHex(rgb);
        if (hex !== this.hex) {
          toSet.hex = hex;
        }
        const colorString = this._computeColorString(hex, rgb.r, rgb.g, rgb.b, hsl.h, hsl.s, hsl.l, this.alpha);
        if (colorString !== this.colorString) {
          toSet.colorString = colorString;
        }
        this.setProperties(toSet);
      }

      /**
       * generate random color
       */
      randomColor() {
        this.setProperties(this.randomRgb());
      }

      /**
       * generate random rgb-color
       * @return {object} rgb-color object
       */
      randomRgb() {
        return {
          r: Math.round(255 * Math.random()),
          g: Math.round(255 * Math.random()),
          b: Math.round(255 * Math.random())
        };
      }

      /**
       * generate random hsl-color
       * @return {object} rgb-color object
       */
      randomHsl() {
        return {
          h: Math.round(359 * Math.random()),
          s: Math.random(),
          l: Math.random()
        };
      }

      hexToRgb(hex) {
        if (hex === undefined) {
          return;
        }
        hex = hex.replace(/[#\s]/g, '');
        if (hex.length === 3) {
          hex = hex.replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
        }

        return {
          r: parseInt(hex.substr(0, 2), 16),
          g: parseInt(hex.substr(2, 2), 16),
          b: parseInt(hex.substr(4, 2), 16)
        };
      }

      rgbToHex(rgb) {
        if (isNaN(rgb.r) || isNaN(rgb.g) || isNaN(rgb.b)) {
          return;
        }
        return '#' + this._componentToHex(Math.round(rgb.r)) + this._componentToHex(Math.round(rgb.g)) + this._componentToHex(Math.round(rgb.b));
      }

      _componentToHex(component) {
        const _hex = component.toString(16);
        if (_hex.length === 1) {
          return `0${_hex}`;
        } else {
          return _hex.slice(0, 2);
        }
      }

      _alphaToHex(alpha, length) {
        const base = Math.pow(16, length) - 1;
        let hex = (Math.round(alpha * base)).toString(16);
        while (length > hex.length)
          hex = '0' + hex;
        return hex;
      }

      _hexToAlpha(hex, length) {
        const base = Math.pow(16, length) - 1;
        // rounding, because browser do use for
        return Math.round(100 * (parseInt(hex, 16) / base)) / 100;
      }

      hslToRgb(hsl) { // not rounded yet
        if (isNaN(hsl.h) || isNaN(hsl.s) || isNaN(hsl.l)) {
          return;
        }
        const t2 = ((hsl.l <= 0.5) ? hsl.l * (hsl.s + 1) : hsl.l + hsl.s - (hsl.l * hsl.s)) * 255,
          t1 = hsl.l * 2 * 255 - t2;
        return {
          r: this._mathMod(this.hueToComponent(t1, t2, hsl.h + 120), 256),
          g: this._mathMod(this.hueToComponent(t1, t2, hsl.h), 256),
          b: this._mathMod(this.hueToComponent(t1, t2, hsl.h - 120), 256)
        };
      }

      hueToComponent(t1, t2, h) {
        if (h < 0) h += 360;
        if (h >= 360) h -= 360;
        if (h < 60) return (((t2 - t1) * h) / 60 + t1);
        else if (h < 180) return t2;
        else if (h < 240) return (((t2 - t1) * (240 - h)) / 60 + t1);
        else return t1;
      }

      rgbToHsl(rgb) {
        if (isNaN(rgb.r) || isNaN(rgb.g) || isNaN(rgb.b)) {
          return;
        }
        const max = Math.max(rgb.r, rgb.g, rgb.b),
          min = Math.min(rgb.r, rgb.g, rgb.b);

        const l = (max + min) / (2 * 255);
        const _c = max - min; // not-normalized chroma (for precision)

        if (_c === 0) {
          return {
            s: 0,
            l: this._normalizedClamp(l)
          };
        }

        const s = _c / (255 - Math.abs(max + min - 255));
        let h;
        switch (max) {
          case rgb.r:
            h = ((rgb.g - rgb.b) * 60) / _c;
            break;
          case rgb.g:
            h = (((rgb.b - rgb.r) * 60) / _c) + 120;
            break;
          case rgb.b:
            h = (((rgb.r - rgb.g) * 60) / _c) + 240;
            break;
        }
        return {
          h: this._mathMod(h, 360),
          s: this._normalizedClamp(s),
          l: this._normalizedClamp(l)
        };
      }

      resetColor() {
        this.setProperties({
          colorString: undefined,
          r: undefined,
          g: undefined,
          b: undefined,
          h: undefined,
          s: undefined,
          l: undefined,
          hex: undefined,
          alpha: 1
        })
      }

      _mathMod(dividend, divisor) {
        return numberUtilities.mathMod(dividend, divisor);
      }

      _normalizedClamp(n) {
        return numberUtilities.normalizedClamp(n);
      }
    }
  }

  window.ColorMixin = Polymer.dedupingMixin(ColorMixin);
</script>
